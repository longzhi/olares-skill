#!/usr/bin/env python3
"""
Olares Nginx Configuration Generator
Auto-generates Nginx reverse proxy configs for each deployed app

Config architecture:
- /etc/nginx/conf.d/default.conf: Main config with include and location /
- /etc/nginx/conf.d/dev/*.conf: Each app's location config
"""

import subprocess
import json
import sys
import os
import shutil
from pathlib import Path

# Auto-detect kubectl path
def find_kubectl():
    # Prefer kubectl from PATH
    kubectl = shutil.which("kubectl")
    if kubectl:
        return kubectl
    # Check common locations
    for path in ["/usr/local/bin/kubectl", "/tmp/kubectl", "/usr/bin/kubectl"]:
        if os.path.isfile(path) and os.access(path, os.X_OK):
            return path
    raise RuntimeError("kubectl not found")

KUBECTL = find_kubectl()

def get_namespace():
    try:
        with open("/var/run/secrets/kubernetes.io/serviceaccount/namespace", "r") as f:
            return f.read().strip()
    except:
        return "default"

NAMESPACE = get_namespace()
NGINX_CONF_DIR = "/etc/nginx/conf.d/dev"
DEFAULT_CONF = "/etc/nginx/conf.d/default.conf"

DEFAULT_CONF_TEMPLATE = """server {
    listen 3000;
    server_name _;
    
    # Include all app routes (must be before location /)
    include /etc/nginx/conf.d/dev/*.conf;
    
    # OpenCode Server default route (fallback)
    location / {
        proxy_pass http://localhost:4096;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Timeout settings - 30 minutes (matches Olares platform)
        proxy_connect_timeout 1800s;
        proxy_send_timeout 1800s;
        proxy_read_timeout 1800s;
        send_timeout 1800s;
        
        # Disable buffering for streaming responses
        proxy_buffering off;
        proxy_cache off;
    }
}
"""


def run_kubectl(args):
    cmd = [KUBECTL] + args + ["-n", NAMESPACE]
    result = subprocess.run(cmd, capture_output=True, text=True)
    return result.returncode, result.stdout, result.stderr


def get_deployed_apps():
    code, stdout, stderr = run_kubectl([
        "get", "deployments",
        "-l", "deployed-by=opencode",
        "-o", "json"
    ])
    
    if code != 0:
        print(f"Error: Unable to get deployment list\n{stderr}", file=sys.stderr)
        return []
    
    data = json.loads(stdout)
    apps = []
    
    for item in data.get("items", []):
        name = item["metadata"]["name"]
        containers = item["spec"]["template"]["spec"]["containers"]
        port = containers[0]["ports"][0]["containerPort"] if containers and containers[0].get("ports") else None
        
        if port:
            apps.append({
                "name": name,
                "port": port,
                "service": f"{name}-svc.{NAMESPACE}.svc.cluster.local"
            })
    
    return apps


def generate_nginx_config(app):
    config = f"""# Auto-generated for {app['name']}
location /{app['name']}/ {{
    proxy_pass http://{app['service']}:{app['port']}/;
    proxy_http_version 1.1;
    
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection $http_connection;
    
    proxy_connect_timeout 1800s;
    proxy_send_timeout 1800s;
    proxy_read_timeout 1800s;
    send_timeout 1800s;
    
    proxy_buffering off;
    proxy_request_buffering off;
}}
"""
    return config


def ensure_default_conf():
    """Ensure default.conf has include directive WITHOUT overwriting user's custom settings"""
    default_conf = Path(DEFAULT_CONF)
    
    if not default_conf.exists():
        print(f"✓ Creating {DEFAULT_CONF}")
        default_conf.write_text(DEFAULT_CONF_TEMPLATE)
        return True
    
    content = default_conf.read_text()
    
    # Check if already contains include directive
    if "include /etc/nginx/conf.d/dev/*.conf" in content:
        return True
    
    # Insert include directive BEFORE first location block (preserve user's timeout settings)
    print(f"⚠️  Adding include directive to {DEFAULT_CONF} (preserving existing settings)")
    
    # Find the position to insert (before first location block)
    if "location / {" in content:
        new_content = content.replace(
            "location / {",
            "# Include app routes (auto-added)\n    include /etc/nginx/conf.d/dev/*.conf;\n\n    location / {"
        )
        default_conf.write_text(new_content)
        print(f"✓ Added include directive (existing config preserved)")
    else:
        # No location block found, use template as fallback
        print(f"⚠️  No location block found, creating from template")
        default_conf.write_text(DEFAULT_CONF_TEMPLATE)
    
    return True


def write_nginx_configs(apps):
    # Ensure config directory exists
    Path(NGINX_CONF_DIR).mkdir(parents=True, exist_ok=True)
    
    # Clear old configs
    for f in Path(NGINX_CONF_DIR).glob("*.conf"):
        f.unlink()
    
    # Write app configs
    for app in apps:
        config_file = Path(NGINX_CONF_DIR) / f"{app['name']}.conf"
        config_content = generate_nginx_config(app)
        config_file.write_text(config_content)
        print(f"✓ Generated config: {config_file}")
    
    print(f"\nTotal: {len(apps)} app config(s) generated")
    
    # Ensure default.conf is correct
    ensure_default_conf()


def reload_nginx():
    print("\nTesting Nginx configuration...")
    
    # Use kill -HUP to reload, avoiding log file issues
    result = subprocess.run(["pgrep", "-f", "nginx: master"], capture_output=True, text=True)
    
    if result.returncode != 0:
        # Nginx not running, start it
        print("Starting Nginx...")
        result = subprocess.run(["nginx"], capture_output=True, text=True)
        if result.returncode == 0:
            print("✓ Nginx started successfully")
            return True
        else:
            print(f"✗ Nginx failed to start:\n{result.stderr}", file=sys.stderr)
            return False
    
    # Nginx is running, reload config
    pid = result.stdout.strip().split('\n')[0]
    print("Reloading Nginx...")
    result = subprocess.run(["kill", "-HUP", pid], capture_output=True, text=True)
    if result.returncode == 0:
        print("✓ Nginx reloaded successfully")
        return True
    else:
        print(f"✗ Nginx reload failed:\n{result.stderr}", file=sys.stderr)
        return False


def show_status():
    print("\n" + "="*60)
    print("Nginx Proxy Status")
    print("="*60)
    
    result = subprocess.run(["pgrep", "-a", "nginx"], capture_output=True, text=True)
    if result.returncode == 0:
        print(f"✓ Nginx is running")
    else:
        print("✗ Nginx is not running")
    
    result = subprocess.run(["ss", "-tlnp"], capture_output=True, text=True)
    nginx_ports = [line for line in result.stdout.split('\n') if 'nginx' in line.lower()]
    if nginx_ports:
        print("\nNginx listening ports:")
        for line in nginx_ports:
            print(f"  {line}")


def main():
    if len(sys.argv) > 1 and sys.argv[1] == "status":
        show_status()
        return
    
    print("Olares Nginx Config Generator")
    print("="*60)
    
    print("\n1. Scanning deployed apps...")
    apps = get_deployed_apps()
    
    if not apps:
        print("  No deployed apps found")
        # Still ensure default.conf is correct
        ensure_default_conf()
        return
    
    print(f"  Found {len(apps)} app(s):")
    for app in apps:
        print(f"    - {app['name']} (port {app['port']})")
    
    print("\n2. Generating Nginx configs...")
    write_nginx_configs(apps)
    
    print("\n3. Applying configuration...")
    if reload_nginx():
        show_status()
        print("\n✅ Configuration complete!")
    else:
        print("\n❌ Configuration failed")
        sys.exit(1)


if __name__ == "__main__":
    main()
